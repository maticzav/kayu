// DO NOT edit this file manually. It was auto-generated using maticzav/ts-graphql.

import {
  composite,
  leaf,
  fragment,
  Field,
  arg,
  Argument,
  SelectionSet,
  Fields,
  selection,
  nullable,
  list,
  OperationType,
  SendInput,
  perform,
} from 'ts-graphql'

/* Scalars */

import * as codecs from './codecs'
export type Scalar = {
  ID: string
  String: string
  Float: number
  Int: number
  Boolean: boolean
  Date: codecs.DateCodec
}

const ScalarMock = {
  ID: '8376',
  String: 'Matic Zavadlal',
  Float: 3.14,
  Int: 92,
  Boolean: true,
  Date: codecs.DateCodec.mock,
}
const ScalarDecoder = {
  ID: (val: string) => val,
  String: (val: string) => val,
  Float: (val: number) => val,
  Int: (val: number) => val,
  Bool: (val: boolean) => val,
  Date: codecs.DateCodec.decode,
}

/* Types */

type DroidObject = {
  __typename: 'Droid'
  appearsIn: Array<Enum['Episode']>
  id: Scalar['ID']
  name: Scalar['String']
  primaryFunction: Scalar['String']
}

type HumanObject = {
  __typename: 'Human'
  appearsIn: Array<Enum['Episode']>
  homePlanet: Scalar['String'] | null
  id: Scalar['ID']
  infoURL: Scalar['String'] | null
  name: Scalar['String']
}

type QueryObject = {
  __typename: 'Query'
  character: Union['CharacterUnion'] | null
  characters: Array<Interface['Character']>
  droid: Object['Droid'] | null
  droids: Array<Object['Droid']>
  greeting: Scalar['String']
  human: Object['Human'] | null
  humans: Array<Object['Human']>
  luke: Object['Human'] | null
  whoami: Scalar['String']
}

export type Object = {
  Droid: DroidObject
  Human: HumanObject
  Query: QueryObject
}

type CharacterInterface =
  | {
      __typename: 'Droid'
      appearsIn: Array<Enum['Episode']>
      id: Scalar['ID']
      name: Scalar['String']
      primaryFunction: Scalar['String']
    }
  | {
      __typename: 'Human'
      appearsIn: Array<Enum['Episode']>
      homePlanet: Scalar['String'] | null
      id: Scalar['ID']
      infoURL: Scalar['String'] | null
      name: Scalar['String']
    }

export type Interface = {
  Character: CharacterInterface
}

type CharacterUnionUnion =
  | {
      __typename: 'Droid'
      appearsIn: Array<Enum['Episode']>
      id: Scalar['ID']
      name: Scalar['String']
      primaryFunction: Scalar['String']
    }
  | {
      __typename: 'Human'
      appearsIn: Array<Enum['Episode']>
      homePlanet: Scalar['String'] | null
      id: Scalar['ID']
      infoURL: Scalar['String'] | null
      name: Scalar['String']
    }

export type Union = {
  CharacterUnion: CharacterUnionUnion
}

enum EpisodeEnum {
  EMPIRE = 'EMPIRE',
  JEDI = 'JEDI',
  NEWHOPE = 'NEWHOPE',
}

enum LanguageEnum {
  EN = 'EN',
  SL = 'SL',
}

export const Enum = {
  Episode: EpisodeEnum,
  Language: LanguageEnum,
}

export type Enum = {
  Episode: EpisodeEnum
  Language: LanguageEnum
}

type GreetingInputObject = {
  language: Enum['Language']
  name: Scalar['String']
}

type GreetingOptionsInputObject = {
  prefix: Scalar['String']
}

export type InputObject = {
  Greeting: GreetingInputObject
  GreetingOptions: GreetingOptionsInputObject
}

/* Operations */

export async function send<TypeLock extends { __typename: 'Query' }, Type>(
  opts: SendInput<TypeLock, Type>,
): Promise<[Type] | [null, Error]> {
  return perform({ operation: opts.selection.operation!, ...opts })
}

/* Documentation */

type Documentation = {
  Droid: {
    appearsIn: () => Array<Enum['Episode']>
    id: () => Scalar['ID']
    name: () => Scalar['String']
    primaryFunction: () => Scalar['String']
  }
  Human: {
    appearsIn: () => Array<Enum['Episode']>
    homePlanet: () => Scalar['String'] | null
    id: () => Scalar['ID']
    infoUrl: () => Scalar['String'] | null
    name: () => Scalar['String']
  }
  Query: {
    character: (params: {
      id: Scalar['ID']
    }) => <T>(selection: SelectionSet<Union['CharacterUnion'] | null, T>) => T
    characters: <T>(
      selection: SelectionSet<Array<Interface['Character']>, T>,
    ) => T
    droid: (params: {
      id: Scalar['ID']
    }) => <T>(selection: SelectionSet<Object['Droid'] | null, T>) => T
    droids: <T>(selection: SelectionSet<Array<Object['Droid']>, T>) => T
    greeting: (params: { input: InputObject['Greeting'] }) => Scalar['String']
    human: (params: {
      id: Scalar['ID']
    }) => <T>(selection: SelectionSet<Object['Human'] | null, T>) => T
    humans: <T>(selection: SelectionSet<Array<Object['Human']>, T>) => T
    luke: <T>(selection: SelectionSet<Object['Human'] | null, T>) => T
    whoami: () => Scalar['String']
  }
  Character: {
    id: () => Scalar['ID']
    name: () => Scalar['String']
    on: <T>(selectors: {
      droid: SelectionSet<Object['Droid'], T>
      human: SelectionSet<Object['Human'], T>
    }) => T
  }
  CharacterUnion: {
    on: <T>(selectors: {
      droid: SelectionSet<Object['Droid'], T>
      human: SelectionSet<Object['Human'], T>
    }) => T
  }
}

/* Selections */

export const objects = {
  droid: <T>(
    selector: (fields: Documentation['Droid']) => T,
  ): SelectionSet<Object['Droid'], T> => {
    const decoder = (fields: Fields<Object['Droid']>): T => {
      const types: Documentation['Droid'] = {
        /* appearsIn */
        appearsIn: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('appearsIn', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return []
            case 'fetched':
              return list(<T>(t: T) => t)(
                data.response.get('appearsIn')(field.hash!),
              )
          }
        },
        /* id */
        id: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('id', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['ID']
            case 'fetched':
              return ScalarDecoder.ID(data.response.get('id')(field.hash!))
          }
        },
        /* name */
        name: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('name', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['String']
            case 'fetched':
              return ScalarDecoder.String(
                data.response.get('name')(field.hash!),
              )
          }
        },
        /* primaryFunction */
        primaryFunction: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('primaryFunction', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['String']
            case 'fetched':
              return ScalarDecoder.String(
                data.response.get('primaryFunction')(field.hash!),
              )
          }
        },
      }
      return selector(types)
    }
    return selection(decoder)
  },
  human: <T>(
    selector: (fields: Documentation['Human']) => T,
  ): SelectionSet<Object['Human'], T> => {
    const decoder = (fields: Fields<Object['Human']>): T => {
      const types: Documentation['Human'] = {
        /* appearsIn */
        appearsIn: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('appearsIn', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return []
            case 'fetched':
              return list(<T>(t: T) => t)(
                data.response.get('appearsIn')(field.hash!),
              )
          }
        },
        /* homePlanet */
        homePlanet: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('homePlanet', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return null
            case 'fetched':
              return nullable(ScalarDecoder.String)(
                data.response.get('homePlanet')(field.hash!),
              )
          }
        },
        /* id */
        id: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('id', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['ID']
            case 'fetched':
              return ScalarDecoder.ID(data.response.get('id')(field.hash!))
          }
        },
        /* infoUrl */
        infoUrl: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('infoURL', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return null
            case 'fetched':
              return nullable(ScalarDecoder.String)(
                data.response.get('infoURL')(field.hash!),
              )
          }
        },
        /* name */
        name: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('name', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['String']
            case 'fetched':
              return ScalarDecoder.String(
                data.response.get('name')(field.hash!),
              )
          }
        },
      }
      return selector(types)
    }
    return selection(decoder)
  },
  query: <T>(
    selector: (fields: Documentation['Query']) => T,
  ): SelectionSet<Object['Query'], T> => {
    const decoder = (fields: Fields<Object['Query']>): T => {
      const types: Documentation['Query'] = {
        /* character */
        character: (params) => (selection) => {
          /* Arguments */
          const args: Argument[] = [arg('id', 'ID!', params.id)]
          /* Selection */
          const field = composite('character', selection.fields, args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selection.mock
            case 'fetched':
              return selection.decode(
                data.response.get('character')(field.hash!),
              )
          }
        },
        /* characters */
        characters: (selection) => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = composite('characters', selection.fields, args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selection.mock
            case 'fetched':
              return selection.decode(
                data.response.get('characters')(field.hash!),
              )
          }
        },
        /* droid */
        droid: (params) => (selection) => {
          /* Arguments */
          const args: Argument[] = [arg('id', 'ID!', params.id)]
          /* Selection */
          const field = composite('droid', selection.fields, args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selection.mock
            case 'fetched':
              return selection.decode(data.response.get('droid')(field.hash!))
          }
        },
        /* droids */
        droids: (selection) => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = composite('droids', selection.fields, args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selection.mock
            case 'fetched':
              return selection.decode(data.response.get('droids')(field.hash!))
          }
        },
        /* greeting */
        greeting: (params) => {
          /* Arguments */
          const args: Argument[] = [arg('input', 'Greeting!', params.input)]
          /* Selection */
          const field = leaf('greeting', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['String']
            case 'fetched':
              return ScalarDecoder.String(
                data.response.get('greeting')(field.hash!),
              )
          }
        },
        /* human */
        human: (params) => (selection) => {
          /* Arguments */
          const args: Argument[] = [arg('id', 'ID!', params.id)]
          /* Selection */
          const field = composite('human', selection.fields, args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selection.mock
            case 'fetched':
              return selection.decode(data.response.get('human')(field.hash!))
          }
        },
        /* humans */
        humans: (selection) => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = composite('humans', selection.fields, args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selection.mock
            case 'fetched':
              return selection.decode(data.response.get('humans')(field.hash!))
          }
        },
        /* luke */
        luke: (selection) => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = composite('luke', selection.fields, args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selection.mock
            case 'fetched':
              return selection.decode(data.response.get('luke')(field.hash!))
          }
        },
        /* whoami */
        whoami: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('whoami', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['String']
            case 'fetched':
              return ScalarDecoder.String(
                data.response.get('whoami')(field.hash!),
              )
          }
        },
      }
      return selector(types)
    }
    return selection(decoder, OperationType.Query)
  },
}

export const unions = {
  characterUnion: <T>(
    selector: (fields: Documentation['CharacterUnion']) => T,
  ): SelectionSet<Union['CharacterUnion'], T> => {
    const decoder = (fields: Fields<Union['CharacterUnion']>): T => {
      const types: Documentation['CharacterUnion'] = {
        on: <T>(selectors: {
          droid: SelectionSet<Object['Droid'], T>
          human: SelectionSet<Object['Human'], T>
        }) => {
          /* Selection */
          fields.select(fragment('Droid', selectors.droid.fields))
          fields.select(fragment('Human', selectors.human.fields))

          /* Mock & Decoder */
          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selectors.droid.mock
            case 'fetched':
              switch (data.response.typename) {
                case 'Droid':
                  return selectors.droid.decode(data.response.raw())
                case 'Human':
                  return selectors.human.decode(data.response.raw())
                default:
                  throw new Error(`Unknown type ${data.response.typename}`)
              }
          }
        },
      }
      return selector(types)
    }
    return selection(decoder)
  },
}

export const interfaces = {
  character: <T>(
    selector: (fields: Documentation['Character']) => T,
  ): SelectionSet<Interface['Character'], T> => {
    const decoder = (fields: Fields<Interface['Character']>): T => {
      const types: Documentation['Character'] = {
        /* id */
        id: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('id', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['ID']
            case 'fetched':
              return ScalarDecoder.ID(data.response.get('id')(field.hash!))
          }
        },
        /* name */
        name: () => {
          /* Arguments */
          const args: Argument[] = []
          /* Selection */
          const field = leaf('name', args)
          fields.select(field)
          /* Mock & Decoder */

          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return ScalarMock['String']
            case 'fetched':
              return ScalarDecoder.String(
                data.response.get('name')(field.hash!),
              )
          }
        },
        on: <T>(selectors: {
          droid: SelectionSet<Object['Droid'], T>
          human: SelectionSet<Object['Human'], T>
        }) => {
          /* Selection */
          fields.select(fragment('Droid', selectors.droid.fields))
          fields.select(fragment('Human', selectors.human.fields))

          /* Mock & Decoder */
          const data = fields.data
          switch (data.type) {
            case 'fetching':
              return selectors.droid.mock
            case 'fetched':
              switch (data.response.typename) {
                case 'Droid':
                  return selectors.droid.decode(data.response.raw())
                case 'Human':
                  return selectors.human.decode(data.response.raw())
                default:
                  throw new Error(`Unknown type ${data.response.typename}`)
              }
          }
        },
      }
      return selector(types)
    }
    return selection(decoder)
  },
}
